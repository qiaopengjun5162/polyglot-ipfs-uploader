// main.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"
)

// ✅ 配置开关
// 设置为 true  -> 生成 1.json, 2.json... (用于需要后缀的合约)
// 设置为 false -> 生成 1, 2... (用于标准 ERC721A 合约)
const USE_JSON_SUFFIX = false

// Attribute 定义了元数据中的属性结构
type Attribute struct {
	TraitType string      `json:"trait_type"`
	Value     interface{} `json:"value"`
}

// NftMetadata 定义了元数据的整体结构
type NftMetadata struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Image       string      `json:"image"`
	Attributes  []Attribute `json:"attributes"`
}

// 核心上传函数 (使用 os/exec)
func uploadToIPFS(targetPath string) (string, error) {
	fmt.Printf("\n--- 正在执行上传命令: ipfs add -r -Q --cid-version 1 %s ---\n", targetPath)

	// 使用 ipfs add 命令上传
	cmd := exec.Command("ipfs", "add", "-r", "-Q", "--cid-version", "1", targetPath)
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	err := cmd.Run()
	if err != nil {
		return "", fmt.Errorf("❌ 上传失败: %s\n%s", err, stderr.String())
	}

	cid := strings.TrimSpace(out.String())
	fmt.Println("✅ 上传成功!")
	fmt.Printf("   - 名称: %s\n", filepath.Base(targetPath))
	fmt.Printf("   - CID: %s\n", cid)
	return cid, nil
}

// 工作流一：处理单个 NFT
func processSingleNFT(imagePath string) {
	fmt.Println("\n==============================================")
	fmt.Println("🚀 开始处理单个 NFT...")
	if USE_JSON_SUFFIX {
		fmt.Println("   - 文件后缀模式: .json")
	} else {
		fmt.Println("   - 文件后缀模式: 无")
	}
	fmt.Println("==============================================")

	// 1. 上传图片文件
	imageCid, err := uploadToIPFS(imagePath)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("\n🖼️  图片 CID 已获取: %s\n", imageCid)

	// 2. 构建元数据
	imageFilename := filepath.Base(imagePath)
	imageNameWithoutExt := strings.TrimSuffix(imageFilename, filepath.Ext(imageFilename))

	metadata := NftMetadata{
		Name:        imageNameWithoutExt,
		Description: fmt.Sprintf("这是一个为图片 %s 动态生成的元数据。", imageFilename),
		Image:       fmt.Sprintf("ipfs://%s", imageCid),
		Attributes: []Attribute{
			{TraitType: "类型", Value: "单件艺术品"},
		},
	}

	// 3. 上传元数据 JSON
	metadataJSON, _ := json.Marshal(metadata)
	cmd := exec.Command("ipfs", "add", "-Q", "--cid-version", "1")
	cmd.Stdin = bytes.NewReader(metadataJSON)
	var out bytes.Buffer
	cmd.Stdout = &out
	err = cmd.Run()
	if err != nil {
		log.Fatalf("❌ 上传 JSON 失败: %v", err)
	}
	metadataCid := strings.TrimSpace(out.String())
	fmt.Printf("\n✅ JSON 元数据上传成功!\n   - CID: %s\n", metadataCid)

	// 4. 本地归档
	outputDir := filepath.Join("output", imageNameWithoutExt)
	os.MkdirAll(outputDir, os.ModePerm)

	// 复制图片
	destImage, _ := os.Create(filepath.Join(outputDir, imageFilename))
	srcImage, _ := os.Open(imagePath)
	destImage.ReadFrom(srcImage)
	destImage.Close()
	srcImage.Close()

	// 保存元数据
	fileName := imageNameWithoutExt
	if USE_JSON_SUFFIX {
		fileName += ".json"
	}
	metadataFile, _ := os.Create(filepath.Join(outputDir, fileName))
	prettyJSON, _ := json.MarshalIndent(metadata, "", "    ")
	metadataFile.Write(prettyJSON)
	metadataFile.Close()

	fmt.Printf("\n💾 图片和元数据已在本地打包保存至: %s\n", outputDir)
	fmt.Println("\n--- ✨ 单件流程完成 ✨ ---")
	fmt.Printf("下一步，您可以在 mint 函数中使用这个元数据 URI: ipfs://%s\n", metadataCid)
}

// 工作流二：处理批量 NFT 集合
func processBatchCollection(imagesInputDir string) {
	fmt.Println("\n==============================================")
	fmt.Println("🚀 开始处理批量 NFT 集合...")
	if USE_JSON_SUFFIX {
		fmt.Println("   - 文件后缀模式: .json")
	} else {
		fmt.Println("   - 文件后缀模式: 无")
	}
	fmt.Println("==============================================")

	// 1. 批量上传整个图片文件夹
	imagesFolderCid, err := uploadToIPFS(imagesInputDir)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("\n🖼️  图片文件夹 CID 已获取: %s\n", imagesFolderCid)

	// 2. 准备并批量生成元数据文件
	timestamp := time.Now().Format("20060102_150405")
	collectionOutputDir := filepath.Join("output", fmt.Sprintf("collection_%s", timestamp))
	imagesOutputDir := filepath.Join(collectionOutputDir, "images")
	metadataOutputDir := filepath.Join(collectionOutputDir, "metadata")

	// 复制图片文件夹
	os.MkdirAll(imagesOutputDir, os.ModePerm)
	filepath.Walk(imagesInputDir, func(path string, info fs.FileInfo, err error) error {
		if !info.IsDir() {
			dest := filepath.Join(imagesOutputDir, info.Name())
			src, _ := os.Open(path)
			dst, _ := os.Create(dest)
			dst.ReadFrom(src)
			src.Close()
			dst.Close()
		}
		return nil
	})
	fmt.Printf("\n💾 所有图片已复制到: %s\n", imagesOutputDir)

	fmt.Println("\n--- 正在为每张图片生成元数据 JSON 文件 ---")
	os.MkdirAll(metadataOutputDir, os.ModePerm)

	files, _ := os.ReadDir(imagesInputDir)
	var imageFiles []string
	for _, file := range files {
		if !file.IsDir() {
			ext := strings.ToLower(filepath.Ext(file.Name()))
			if ext == ".png" || ext == ".jpg" || ext == ".jpeg" || ext == ".gif" {
				imageFiles = append(imageFiles, file.Name())
			}
		}
	}
	sort.Strings(imageFiles)

	for _, fileName := range imageFiles {
		tokenIDStr := strings.TrimSuffix(fileName, filepath.Ext(fileName))
		tokenID, _ := strconv.Atoi(tokenIDStr)
		metadata := NftMetadata{
			Name:        fmt.Sprintf("MetaCore #%d", tokenID),
			Description: "MetaCore 集合中的一个独特成员。",
			Image:       fmt.Sprintf("ipfs://%s/%s", imagesFolderCid, fileName),
			Attributes:  []Attribute{{TraitType: "ID", Value: tokenID}},
		}

		outFileName := tokenIDStr
		if USE_JSON_SUFFIX {
			outFileName += ".json"
		}
		file, _ := os.Create(filepath.Join(metadataOutputDir, outFileName))
		prettyJSON, _ := json.MarshalIndent(metadata, "", "    ")
		file.Write(prettyJSON)
		file.Close()
	}
	fmt.Printf("✅ 成功生成 %d 个元数据文件到: %s\n", len(imageFiles), metadataOutputDir)

	// 3. 批量上传整个元数据文件夹
	metadataFolderCid, err := uploadToIPFS(metadataOutputDir)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("\n📄 元数据文件夹 CID 已获取: %s\n", metadataFolderCid)
	fmt.Println("\n--- ✨ 批量流程完成 ✨ ---")
	fmt.Printf("下一步，您可以在合约中将 Base URI 设置为: ipfs://%s/\n", metadataFolderCid)
}

func main() {
	// --- 前置检查 ---
	cmd := exec.Command("ipfs", "id")
	if err := cmd.Run(); err != nil {
		fmt.Println("❌ 连接 IPFS 节点失败。")
		fmt.Println("请确保你的 IPFS 节点正在运行 (命令: ipfs daemon)。")
		os.Exit(1)
	}
	fmt.Println("✅ 成功连接到 IPFS 节点")

	// --- 准备工作 ---
	// singleImagePath := filepath.Join("..", "assets", "image", "IMG_20210626_180340.jpg")
	batchImagesPath := filepath.Join("..", "assets", "batch_images")
	os.MkdirAll(batchImagesPath, os.ModePerm)

	// --- 在这里选择要运行的工作流 ---

	// 运行工作流一：处理单个 NFT
	// processSingleNFT(singleImagePath)

	// 运行工作流二：处理批量 NFT 集合
	processBatchCollection(batchImagesPath)

	// 生产环境最终发布流程说明
	fmt.Println("\n======================================================================")
	fmt.Println("✅ 本地准备工作已完成！")
	fmt.Println("下一步是发布到专业的 Pinning 服务 (如 Pinata):")
	fmt.Println("1. 登录 Pinata。")
	fmt.Println("2. 上传您本地 `go/output/collection_[时间戳]/images` 文件夹。")
	fmt.Println("3. 上传您本地 `go/output/collection_[时间戳]/metadata` 文件夹。")
	fmt.Println("4. ⚠️  使用 Pinata 返回的【metadata】文件夹的 CID 来设置您合约的 Base URI。")
	fmt.Println("======================================================================")
}


/**
polyglot-ipfs-uploader/go on  main [!?] via 🐹 v1.24.5 on 🐳 v28.2.2 (orbstack)
➜ go run ./main.go
✅ 成功连接到 IPFS 节点

==============================================
🚀 开始处理批量 NFT 集合...
   - 文件后缀模式: .json
==============================================

--- 正在执行上传命令: ipfs add -r -Q --cid-version 1 ../assets/batch_images ---
✅ 上传成功!
   - 名称: batch_images
   - CID: bafybeia22ed2lhakgwu76ojojhuavlxkccpclciy6hgqsmn6o7ur7cw44e

🖼️  图片文件夹 CID 已获取: bafybeia22ed2lhakgwu76ojojhuavlxkccpclciy6hgqsmn6o7ur7cw44e

💾 所有图片已复制到: output/collection_20250726_160112/images

--- 正在为每张图片生成元数据 JSON 文件 ---
✅ 成功生成 3 个元数据文件到: output/collection_20250726_160112/metadata

--- 正在执行上传命令: ipfs add -r -Q --cid-version 1 output/collection_20250726_160112/metadata ---
✅ 上传成功!
   - 名称: metadata
   - CID: bafybeiczqa75ljidb7esu464fj6a64nfujxcd2mum73t5yaw2llkrzb4zy

📄 元数据文件夹 CID 已获取: bafybeiczqa75ljidb7esu464fj6a64nfujxcd2mum73t5yaw2llkrzb4zy

--- ✨ 批量流程完成 ✨ ---
下一步，您可以在合约中将 Base URI 设置为: ipfs://bafybeiczqa75ljidb7esu464fj6a64nfujxcd2mum73t5yaw2llkrzb4zy/

======================================================================
✅ 本地准备工作已完成！
下一步是发布到专业的 Pinning 服务 (如 Pinata):
1. 登录 Pinata。
2. 上传您本地 `go/output/collection_[时间戳]/images` 文件夹。
3. 上传您本地 `go/output/collection_[时间戳]/metadata` 文件夹。
4. ⚠️  使用 Pinata 返回的【metadata】文件夹的 CID 来设置您合约的 Base URI。
======================================================================

polyglot-ipfs-uploader/go on  main [!?] via 🐹 v1.24.5 on 🐳 v28.2.2 (orbstack)
➜ go run ./main.go
✅ 成功连接到 IPFS 节点

==============================================
🚀 开始处理单个 NFT...
   - 文件后缀模式: .json
==============================================

--- 正在执行上传命令: ipfs add -r -Q --cid-version 1 ../assets/image/IMG_20210626_180340.jpg ---
✅ 上传成功!
   - 名称: IMG_20210626_180340.jpg
   - CID: bafybeifwvvo7qacd5ksephyxbqkqjih2dmm2ffgqa6u732b2evw5iijppi

🖼️  图片 CID 已获取: bafybeifwvvo7qacd5ksephyxbqkqjih2dmm2ffgqa6u732b2evw5iijppi

✅ JSON 元数据上传成功!
   - CID: bafkreihhpbkssgrr22r3f3rhrb4hntmbdzfm3ubaun2cfw4p5vyhcgivbi

💾 图片和元数据已在本地打包保存至: output/IMG_20210626_180340

--- ✨ 单件流程完成 ✨ ---
下一步，您可以在 mint 函数中使用这个元数据 URI: ipfs://bafkreihhpbkssgrr22r3f3rhrb4hntmbdzfm3ubaun2cfw4p5vyhcgivbi

======================================================================
✅ 本地准备工作已完成！
下一步是发布到专业的 Pinning 服务 (如 Pinata):
1. 登录 Pinata。
2. 上传您本地 `go/output/collection_[时间戳]/images` 文件夹。
3. 上传您本地 `go/output/collection_[时间戳]/metadata` 文件夹。
4. ⚠️  使用 Pinata 返回的【metadata】文件夹的 CID 来设置您合约的 Base URI。
======================================================================

polyglot-ipfs-uploader/go on  main [!?] via 🐹 v1.24.5 on 🐳 v28.2.2 (orbstack)
➜ go run ./main.go
✅ 成功连接到 IPFS 节点

==============================================
🚀 开始处理单个 NFT...
   - 文件后缀模式: 无
==============================================

--- 正在执行上传命令: ipfs add -r -Q --cid-version 1 ../assets/image/IMG_20210626_180340.jpg ---
✅ 上传成功!
   - 名称: IMG_20210626_180340.jpg
   - CID: bafybeifwvvo7qacd5ksephyxbqkqjih2dmm2ffgqa6u732b2evw5iijppi

🖼️  图片 CID 已获取: bafybeifwvvo7qacd5ksephyxbqkqjih2dmm2ffgqa6u732b2evw5iijppi

✅ JSON 元数据上传成功!
   - CID: bafkreihhpbkssgrr22r3f3rhrb4hntmbdzfm3ubaun2cfw4p5vyhcgivbi

💾 图片和元数据已在本地打包保存至: output/IMG_20210626_180340

--- ✨ 单件流程完成 ✨ ---
下一步，您可以在 mint 函数中使用这个元数据 URI: ipfs://bafkreihhpbkssgrr22r3f3rhrb4hntmbdzfm3ubaun2cfw4p5vyhcgivbi

======================================================================
✅ 本地准备工作已完成！
下一步是发布到专业的 Pinning 服务 (如 Pinata):
1. 登录 Pinata。
2. 上传您本地 `go/output/collection_[时间戳]/images` 文件夹。
3. 上传您本地 `go/output/collection_[时间戳]/metadata` 文件夹。
4. ⚠️  使用 Pinata 返回的【metadata】文件夹的 CID 来设置您合约的 Base URI。
======================================================================

polyglot-ipfs-uploader/go on  main [!?] via 🐹 v1.24.5 on 🐳 v28.2.2 (orbstack)
➜ go run ./main.go
✅ 成功连接到 IPFS 节点

==============================================
🚀 开始处理批量 NFT 集合...
   - 文件后缀模式: 无
==============================================

--- 正在执行上传命令: ipfs add -r -Q --cid-version 1 ../assets/batch_images ---
✅ 上传成功!
   - 名称: batch_images
   - CID: bafybeia22ed2lhakgwu76ojojhuavlxkccpclciy6hgqsmn6o7ur7cw44e

🖼️  图片文件夹 CID 已获取: bafybeia22ed2lhakgwu76ojojhuavlxkccpclciy6hgqsmn6o7ur7cw44e

💾 所有图片已复制到: output/collection_20250726_160334/images

--- 正在为每张图片生成元数据 JSON 文件 ---
✅ 成功生成 3 个元数据文件到: output/collection_20250726_160334/metadata

--- 正在执行上传命令: ipfs add -r -Q --cid-version 1 output/collection_20250726_160334/metadata ---
✅ 上传成功!
   - 名称: metadata
   - CID: bafybeidcdd6osm2gvnxt3vlp434kmfq673fbkv4xtrrkqkpbkqe6iakvdm

📄 元数据文件夹 CID 已获取: bafybeidcdd6osm2gvnxt3vlp434kmfq673fbkv4xtrrkqkpbkqe6iakvdm

--- ✨ 批量流程完成 ✨ ---
下一步，您可以在合约中将 Base URI 设置为: ipfs://bafybeidcdd6osm2gvnxt3vlp434kmfq673fbkv4xtrrkqkpbkqe6iakvdm/

======================================================================
✅ 本地准备工作已完成！
下一步是发布到专业的 Pinning 服务 (如 Pinata):
1. 登录 Pinata。
2. 上传您本地 `go/output/collection_[时间戳]/images` 文件夹。
3. 上传您本地 `go/output/collection_[时间戳]/metadata` 文件夹。
4. ⚠️  使用 Pinata 返回的【metadata】文件夹的 CID 来设置您合约的 Base URI。
======================================================================
*/